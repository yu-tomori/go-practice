Goの組み込み型

整数
int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, uintptr, byte, rune

浮動小数点数
float32, float64

複素数
complex64, complex128

文字列
string

真偽値
bool

エラー
error


変数のゼロ値
・Goの変数は明示的な初期化をしなくても使える
    ・ゼロ値という値が設定され、型によっても違う
intやfloat64などの数値 -> 0
string -> ""
bool -> false
error -> nil


定数
・値の変わらないもの
・コンパイル時から値が変わらないもの
・リテラルで記述されることが多い
数値リテラル -> 100, 1.5, 1+4i
文字列リテラル -> "hoge"
ルーンリテラル -> 'A', '世'
真偽値リテラル -> true, false


2進数・8進数・16進数表記
・10進数表記以外にも対応
・数字の前にプレフィックスをつける
10進数 -> 100, 10.5
2進数 -> 0b1100100
8進数 -> 0144, 0o144(Go1.13)
16進数 -> 0x64, 0x1.5p+03(Go1.13)


数字の区切り
・桁を区切りたい場合などに使える
5_000_000_000_000
0b_1010_1010
3.1415_9265

定数式
・定数のみからなる演算式
・コンパイル時に計算される
四則演算 -> 100 + 200 -> 300
シフト演算 -> 1 << 2 -> 4
文字列結合 -> "Hello, " + "世界" -> "Hello, 世界"
関係演算/論理演算 -> !(10 == 20) -> true

名前付き定数
・定数に名前をつけて定義する
・変数定義といたように定数に名前がつけられる

定数の型
・型を持たない定数
・型を明示しない場合に定数は型を持たず、デフォルトの型を持つ
種類 | 例 | デフォルトの型
整数 | 100 | int
浮動小数点数 | 1.5 | float64
複素数 | 1+4i | complex128
ルーン | 'A', '世' | rune
文字列 | "hoge" | string
真偽値 | true | bool

右辺の省略
・名前付き定数定義の右辺が省略できる
・グループ化された名前付き定数で用いられる
・2つ目以降の名前付き定数の右辺を省略できる
・2つ目以降の定数定義の右辺は、1つめの定数の右辺と同じになる


コンポジット型
・複数のデータ型が集まって一つのデータ型になっている
1. 構造体・・・型の異なるデータ型を集めたデータ型
2. 配列・・・同じ型のデータを集めて並べたデータ型
3. スライス・・・配列の一部を切り出したデータ型
4. マップ・・・キーと値をマッピングさせたデータ型

コンポジット型のゼロ値
・データの表現方法によって違う
・構造体や配列は要素が全てゼロ値の値
・スタイスやマップはmakeなどで初期化が必要なためnilとなる
構造体 -> フィールドが全てゼロ値
配列 -> 要素が全てゼロ値
スライス -> nil
マップ -> nil

型リテラル
・型リテラルとは型の具体的な定義を書き下した型の表現方法
・コンポジット型などを表現するために使う
・変数定義やユーザ定義型などで使用する
・リテラルとは、識別子が付与されていないもの、という意味

構造体
・型の異なるデータ型の変数を集めたデータ型
・各変数はフィールドと呼ばれる
・フィールドの型は異なっても良い
・フィールドの型には組み込み型以外も使える
・コンポジット型やユーザ定義型も使える
構造体リテラル
・フィールドを指定して初期化

配列
・同じ型のデータを集めて並べたデータ構造
・要素の型は全て同じ
・要素数が違えば別の型
・要素数は変更できない
・型は型リテラルで記述することが多い

スライス
・配列の一部を切り出したデータ構造
・要素の型は全て同じ
・要素数は型情報に含まない
・背後に配列が存在する

スライスと配列の関係
・スライスはベースとなる配列が存在している

appendの挙動
・容量が足りるばあ愛
    新しい要素をコピーする
    lenを更新する
・容量が足りない場合
    元のおよそ2倍の容量の配列を確保し直す
    配列へのポインタを貼り直す
    元の配列から要素をコピーする
    新しい要素をコピーする
    lenとcapを更新する

マップ
・キーと値をマッピングさせるデータ構造
・キーと値の型を指定する
・キーには「==」で比較できる型しかNG

コンポジット型を要素にする
・コンポジット型を要素として持つコンポジット型
・スライスの要素がスライスの場合(2次元スライス) ex) [][]int
・マップの値がスライスの場合 ex) map[string][]int
・構造体のフィールドの型が構造体

関数
・一連の操作をまとめたもの
・引数で受け取った値をもとに処理を行い戻り値として結果を返す機能
・必ずしも引数や戻り値がなくても良い
・引数:関数の入力となるもの
・戻り値:関数の出力となあるもの
・関数の種類
・組み込み関数 -> 言語の機能として組み込まれている関数
・ユーザ定義関数 -> ユーザが定義した関数

関数呼び出し
・引数を指定して呼び出す
・引数は変数や式を指定しても良い
・引数が複数ある場合はカンマで区切って指定する
・戻り値がある場合は変数に代入したり式中で使う

組み込み関数
print/println -> 表示を行う
make -> コンポジット型の初期化
new -> 指定した型のメモリの確保
len/cap -> スライスなどの長さ/容量を返す
copy -> スライスのコピーを行う
delete -> マップから指定したキーのエントリを削除
complex -> 複素数型を作成
imag/real -> 複素数の虚部/実数部を取得
panic/recover -> パニックを起こす/回復する

関数の定義
・関数の定義方法
func add(x int, y int) int {
    return x + y
}

・複数の戻り値を返す
func swap(x, y int) (int , int) {
    return y, x
}

多値の受け取り方
・カンマで区切って受け取ることができる
x, y := swap(10, 20)
・省略したい場合は＿(ブランク変数)を用いる
x, _ := swap(10, 20)
＿, y := swap(10, 20) _

関数ん定義
func swap(x, y int) (x2, y2 int ) {
    y2, x2 = x, y
    return
}

値の入れ替え
・一時変数なしで値を入れ替えることができる
・右辺もカンマ区切りで式を書くことができる
x, y = y, x

無名関数
・名前のない関数のこと(クロージャーとも呼ばれる)

関数型
関数はファーストクラスオブジェクト
・変数への代入
・引数に渡す
・戻り値で返す

クロージャとよくあるバグ
定義と実行のタイミングを気をつけるべし
・関数外の変数(自由変数)を参照している場合
・実行のタイミングでは値が変わっている可能性がある

値のコピー
代入ではコピーが発生する
・代入元と同じ値がコピーされる
・コピーのため、代入後の変数に変更を加えても代入前の変数には影響を与えない
・関数の引数や戻り値でも同様のことが起きる

ポインタ
変数の格納先のメモリ番地を表す値
・値で渡される型の値に対して破壊的な操作を加える際に利用する

内部でポインタを使っているデータ型
・コンポジット型の一部
    ・スライス、マップ、チャネル
・これらの型はポインタを用いる必要がない

メソッド
レシーバと紐づけられた関数
・データとそれに対する操作を紐づけるために用いる
・ドットでメソッドにアクセスする

レシーバ
メソッドに関連づけられた変数
・メソッド呼び出し時には通常の引数と同じような扱いになる
・ポインタを用いることでレシーバへの変更を呼び出し元に伝えることができる

メソッド値
メソッドも値として扱える
・レシーバは束縛された状態

メソッド式
・メソッドを表す式
・レシーバを第一引数とした関数になる

パッケージ
・関数や変数、定数、型を意味のある単位でまとめたもの
・Goのプログラムはパッケージを組み合わせることで実現される

型
・データの種類を表したもの

関数
・処理を意味のある単位でまとめたもの
・パッケージに属さない組み込み関数も存在する

変数
・処理中に使用するデータを格納したもの

定数(名前付き定数)
・コンパイル時から変わらない値に名前をつけたもの

パッケージの種類
mainパッケージ
・main関数の存在するパッケージ
・プログラムの起点(エントリポイント)となるパッケージ
・実行可能なGoのプログラムの場合には必ず存在する
標準パッケージ
・Goが最初から容姿しているパッケージ
・100以上のパッケージが存在する
サードパーティパッケージ
・第三者が開発したパッケージ
・インストールすることで使える
・ライブラリとも呼ばれる

パッケージのインポート
・他のパッケージの機能を使う
・インポートすることで使えるようになる
・インポートはIDEやgoimportsなどのツールに任せる

・パッケージをインポートしてできること
・別のパッケージで用意された機能を使用できる(変数、関数、定数など)

パッケージ名のエイリアス
・別名をつける
・インポートパスの左側に変えたい名前を書く
・同じパッケージ名のパッケージを使いたい場合に使う
・インポートパスとパッケージ名が一致していない場合に用いる

パッケージ外へのエクスポート
    ・エスクポート
        ・先頭を大文字にした識別子がエクスポートされる
        ・他のパッケージから利用できるようになる
    ・ライブラリ
        ・main関数のないGoのプログラム
        ・エクスポートされたものを使用する

GOPATH
    ・GOPATHとは？
        ・Goのソースコードやビルドされたファイルが入るパスが設定される
        ・インポートされるパッケージもここから検索される

$GOPATH/bin/ -> ビルドされた実行可能ファイルが入る
       /pkg/ -> ビルドされたパッケージが入る
       /src/ -> 実行可能なGoのコード or ライブラリのGoのコード

GOPATHの設定方法
    ・環境変数として設定
    ・デフォルトが決まっている
        ・Unix系 -> $HOME/go
        ・Windows系 -> %USERPROFILE%\go
    ・複数設定できる
    ・go env GOPATH コマンドで取得可能

スコープ
    / スコープ
        / 識別子(変数名、関数名など)を参照できる範囲
        / 参照元によって所属するスコープが違う
        / 親子関係があり親のスコープの識別子は参照できる
    / Goのスコープ
        / レキシカルスコープを採用
        / スコープは4種類
            / ブロック
            / ファイル
            / パッケージ
            / ユニバース

ブロックスコープ
    ブロックごとのスコープ
        / 関数やif, forなどのブロック単位のスコープ
        / ブロック内で宣言した識別子はブロック内でしか参照できない

ファイルスコープ
    ファイルごとのスコープ
        / ファイル内でインポートしたパッケージを保持するスコープ
        / パッケージ以外は対象としていない

パッケージスコープ
    パッケージごとのスコープ
        / パッケージ単位になる
        / 大文字から始める識別子は他のパッケージからも参照できる

パッケージ変数
    関数間で変数を共有するためには
        / 関数内で定義した変数は関数を出ると消えてしまう
        / 関数をまたいだデータの共有には2種類方法がある
            / パッケージ変数
            / メソッドを用いる
        / 関数と同じレベル変数を定義すればOK
            / :=の記法は関数内でしか使えない

ユニバーススコープ
    組み込み型や組み込み関数を保持するスコープ
        / プログラム実行時からずっとあるスコープ
        / 他のスコープの一番ルートとなるスコープ

パッケージの初期化
    依存パッケージの初期化
        / import しているパッケージリストを出す
        / 依存関係を解決して依存されていないパッケージから初期化していく
    各パッケージの初期化
        / パッケージ変数の初期化する
        / init関数の実行を行う

init関数
    パッケージの初期化を行う関数
        / パッケージの初期化時に呼び出される関数
        / 複雑な初期化を行う場合に用いる
            / パッケージ変数への代入文だけでは表現できない場合
        / 1パッケージに複数用意しても良い
        / 1ファイルに複数用意しても良い
        / 実行順がシビアなものはinit関数には書かない
        / エラーハンドリングが必要な処理は書かない
        / init関数は明示的には呼び出さない

go get でライブラリの取得をする
    go get コマンド
        / Goのライブラリなどを取得するコマンド
        / 依存するライブラリも一緒に取得してくれる
        / 指定した場所からダウンロード＆インストールしてくれる
        / 一度取得したものは2度取得しない
        / -uオプションでダウンロードを強制する

modules (vgo)
    標準のモジュール管理の仕組み
        / https://golang.github.io/dep/
        / Go1.11/Go1.12でテクニカルレビュー
        / Go1.13で正式導入
    modulesの特徴
        / ビルド時に依存関係を解決する(go toolのように)
        / ベンダリングが不要になる
        / 新しくモジュールという概念単位でバージョン管理をする
        / 互換性がなくなる場合はインポートパスを変える
        / 可能な限り古いバージョンが優先される(Minimal Version Selection)

Go1.0以前の話
    Makefileを使っていた
        / 6g(コンパイラ)や61(リンカ)を使ってビルド
        / サンプルのMakefileが付いていてそれを利用していた
        / 依存関係はMakefilenの中に書かれていた
        / gobuildというラッパーも存在していた

goinstallの登場
    / 2010年2月に登場
    / GithubやBitbucketからダウンロードして配置する
    / Makefileほどの柔軟性はないが利便性が工場
    / インポートパスのルールの確立
        / ソースコード中に全ての依存関係が記述される
        / go vetなどの静的解析ツールが簡単に作れるようになった
    / 2012年2月のGo1.0リリースでgo getに

go getの登場で解決したこと
    / 簡単にビルドができるようになった
    / 作ったものを簡単に公開・再利用できるようになった
        / 現在のGoコミュニティを形成する上で重要なファクター
        / go getすることで簡単に他の人が作ったパッケージを利用できる
    / ビルドシステムを意識しなくて良い
        / 6gや6lなどを気にしなくて良い
        / 依存関係の解決方法などは勝手にやってくれる

go getで解決できなかったこと
    バージョン付けとAPIの安定性
        / バージョン付ができない
        / アップデートによって何が変わるのかユーザに提示できない
        / gopkg.inなどの登場
    ベンダリングとビルドの再現可能性
        / ビルドの再現性が取れない
        / 取得時に常に最新を見てしまうこと
        / godep、glide、GBなどの登場
        / ベンダリングの対応(Go1.5以上)

ベンダリング
    ライブラリのベンダリング
        / verndor以下に置くとimportで優先される
        / バージョン指定はできない

depの登場
    公式によるバージョン管理の導入の実験
        / GopherCon 2016のHack Dayで議論が行われた
        / そこからdepが登場した
        / https://github.com/golang/dep
    The New Era of Go Package Management
        / GopherCon 2017においての発表
        / depのやっていきを発表
        / semverの推奨

そしてmodules(vgo)へ
    modules(vgo)で提案すること
        / Import Compatibility Rule
        / Minimal Version Selection
        / モジュールの導入
        / 現在のワークフローを壊さずにgo toolに導入する

Import Compatibility Rule
    importパスが同じ場合は後方互換性を維持する
        / 後方互換性が取れない場合はインポートパスを返す
    import "github.com/tenntenn/hoge" -> import hoge "github.com/tenntenn/hoge/v2"

Minimal Version Selection
    最小バージョンの選択
        / 選択できるバージョンのうち最も古いバージョンを選択
        / どんどんバージョンアップされても常に同じものを使う
        / 特定のバージョンを指定すれば新しいものを使うことはできる
        / 依存モジュールの下限だけ指定することによって、一意にビルド

モジュール
    バージョン付けを行う単位
        / go.modファイルを使って依存モジュールを記述
        / バージョンはsemverで記述する
        / 特定のコミットも指定できる

セマンティックバージョニング
    バージョンの付け方のルール
        / semverと略される
        / v0.0.2やv.11.1などと表記する
    バージョンの上げ方
        / 互換性が崩れる場合->メジャーバージョン(ex. v1.2.3 -> v2.0.0)
        / 機能追加の場合    ->マイナーバージョン(ex. v1.2.3 -> v1.3.0)
        / バグ修正の場合    ->パッチバージョン  (ex. v1.2.3 -> v1.2.4)

modulesが普及するために必要なこと
    modules(vgo)が登場した背景の理解
        / Go & Versioningを読みましょう
    semverによるバージョン管理
        / 自分のライブラリをsemverで管理しましょう
        / 自分の使っているライブラリにissueを上げる

go modコマンド
    go modコマンドを有効にする
        / 環境変数のGO111MODULEをonにする
        / Windowsの場合: set GO111MODULE=on
go mod init                 -> 指定したモジュール名でgo.modファイルを生成する
go mod tidy                 -> 使用していないパッケージのgo.modからの削除。必要なパッケージのダウンロードとgo.modへの追加
go mod why                  -> 指定したパッケージがなぜ必要になったかを表示
go mod vendor               -> 依存するパッケージをvendor以下にコピーする


プログラム引数
    プログラム実行時に渡される引数
        / プログラムに対して外から渡されるデータ・情報
        / ターミナル上でコマンドを入力する際に使用する
        / コマンドライン引数=プログラム引数

プログラム引数を取得する
    os.Argsを使用する
        / プログラム引数が入った文字列型のスライス
        / 要素の一つ目はプログラム名

flagパッケージ
    フラグ(オプション)を便利に扱うパッケージ

flagパッケージとプログラム引数
    flag.Args関数を用いる
        / os.Argsだとフラグも含まれる
        / flag.Args関数はフラグの分は除外される
参考: https://qiita.com/Yaruki00/items/7edc04720a24e71abfa2

入出力の抽象化
    io.Readerとio.Writer
        / 入出力を抽象化したioパッケージで提供される型
        / それぞれ1つのメソッドしか持たないので実装が楽
        / 入出力をうまく抽象化し、様々な型を透過的に扱える
            / ファイル、ネットワーク、メモリ etc...
        / パイプのように簡単に入出力を繋げられる

標準入力と標準出力
    osパッケージで提供されている*os.File型の変数
        / io.Readerとio.Writerを実装している
        / 様々な関数やメソッドの引数として渡せる
        / 標準入力 -> os.Stdin
        / 標準出力 -> os.Stdout
        / 標準エラー出力 -> os.Stderr

プログラムの終了
    os.Exit(code int)
        / 終了コードを指定してプログラムを終了
        / プログラムの呼び出し元に終了状態を伝えられる
        / 0: 成功(デフォルト)

プログラムの終了
    log.Fatal
        / 標準エラー出力(os.Stderr)にエラーメッセージを表示
        / os.Exit(1)で異常終了させる

defer
    関数の遅延実行
        / 関数終了時に実行される
        / 引数の評価はdefer呼び出し後
        / スタック形式で実行される(最後に呼び出したものが最初に実行)

forの中でdeferは避ける
    予約した関数の呼び出しはreturn時に実行される
        / forの中を関数に分ければ良い

入出力関連の便利パッケージ
    encoding -> JSONやXML、CSV(TSV)などのエンコードを扱うことができる
    strings -> 文字周りの処理がある
    bufio -> Scannerが便利
    strconv -> 文字列への変換を行う関数を提供
    unicode -> Unicode周りの処理を提供

ファイルパスを扱う
    path/filepathパッケージを使う
        / OSに寄らないファイルパスの処理が行える

インタフェースと抽象化
    抽象化
        / 具体的な実装を隠し振る舞いによって共通化させること
        / 複数の実装を同質のものとして扱う
    インタフェースによる抽象化
        / Goではインタフェースでしか抽象化をすることができない

インタフェース
    型TがインタフェースIを実装しているとは
        / インタフェースで定義されているメソッドを全て持つ
        / 型TはインタフェースI型として振舞うことができる
            / var i I = t // tはT型の変数とする

    インタフェースはメソッドの集まり
        / メソッドのリストがインタフェースで規定しているものと一致する型はインタフェースを実装していることになる

interface()
    empty interface
        / メソッドリストが空なインタフェース
        / つまりどの型の値も実装していることになる
        / JavaのObject型のような使い方ができる

fmt.Stringer
    fmt.Stringer contains a object which is of type GoStringer.
    GoStringer is implemented by any value that has a GoString method, which defines
    the Go syntax for that value. The GoString method is used to print values passed
    as an operand to a %#v format.

インタフェースの設計
    メソッドリストは小さく
        / 共通点を抜き出して抽象化しない
        / 一塊の振る舞いを一つのインタフェースにする
        / 型を使うユーザが触れる部分がインタフェースでなくても良い
            / 内部にエンジンやドライバの形で抽象化したものを持つ
            / http.Client内部のhttp.RountTripperのようなj感じ
    型階層は作れない
        / Goでは型階層は作れない
        / 抽象化はすべてインタフェース
        / 型階層ではなくコンポジットで表現する

io.Readerとio.Writer
    入出力の抽象化
        / 入出力を抽象化したioパッケージで提供される型
        / それぞれ一つのメソッドしか持たないので実装が楽
        / 入出力をうまく抽象化し、さまざまな型を透過的に扱える
            / ファイル、ネットワーク、メモリ etc...
        / パイプのように簡単に入出力を繋げられる

io.Reader
    Reader is the interface that wraps that basic Read method.
    Read reads up to len(p) bytes into p. It returns the number of bytes read(0 <= n <= len(p))
    end any error encountered.
    Even if Read returns n < len(p), it may use all of p as scratch space during the call.
    if some data is available but not len(p) bytes, Read conventionally returns what is available instead of waiting for more.
    When Read encouteres an error or end-of-file condition after successfully reading n > 0 bytes, it returns the number of bytes read.
    It may return the (non-nil) error form the same call or return the error (and n == 0) from a subsequent call. An instance of this general case is that a Reader returning a non-zero number of bytes at the end of the input stream may return either err == EOF or err == nil. The next Read should return 0, EOF.
    Callers should always process the n > 0 bytes returnd before considering the error err. Doing so correctly handles I/O errors that happen after reading some bytes and also both of the allowed EOF behaviors.
    Implementations of Read are discouraged form returning a zero byte count with a nil erorr, except when len(p) == 0. Callers should treat a return of 0 and nil as indicating that nothing happened; in particular it does not indicate EOF.

io.Writer
    Writer is the interface that wraps the basic Write method.
    Writer writes len(p) bytes from p to the underlying data stream. It returns the number of bytes written from p (0 <= n <= len(p)) and any error encountered that caused the write to stop early. Write must return a non-nil error if it returns n < len(p). Write must not modify the slice data, even temporarily.




